# Alias for bool is used because tensorflow name shadows bool with tf.bool.
from builtins import bool as _bool
from typing import Any, Iterable, Iterator, NoReturn, overload

import numpy as np
from tensorflow._aliases import _TensorCompatible

# Most tf.math functions are exported from tf., but not all of them are.
from tensorflow.math import abs as abs

def __getattr__(name: str) -> Any: ...  # incomplete

class Tensor:
    @property
    def shape(self) -> TensorShape: ...
    def get_shape(self) -> TensorShape: ...
    @property
    def name(self) -> str: ...
    def numpy(self) -> np.ndarray[Any, Any]: ...
    def __int__(self) -> int: ...
    def __abs__(self) -> Tensor: ...
    def __add__(self, other: _TensorCompatible) -> Tensor: ...
    def __radd__(self, other: _TensorCompatible) -> Tensor: ...
    def __sub__(self, other: _TensorCompatible) -> Tensor: ...
    def __rsub__(self, other: _TensorCompatible) -> Tensor: ...
    def __mul__(self, other: _TensorCompatible) -> Tensor: ...
    def __rmul__(self, other: _TensorCompatible) -> Tensor: ...
    def __matmul__(self, other: _TensorCompatible) -> Tensor: ...
    def __rmatmul__(self, other: _TensorCompatible) -> Tensor: ...
    def __floordiv__(self, other: _TensorCompatible) -> Tensor: ...
    def __rfloordiv__(self, other: _TensorCompatible) -> Tensor: ...
    def __truediv__(self, other: _TensorCompatible) -> Tensor: ...
    def __rtruediv__(self, other: _TensorCompatible) -> Tensor: ...
    def __neg__(self) -> Tensor: ...
    def __and__(self, other: _TensorCompatible) -> Tensor: ...
    def __rand__(self, other: _TensorCompatible) -> Tensor: ...
    def __or__(self, other: _TensorCompatible) -> Tensor: ...
    def __ror__(self, other: _TensorCompatible) -> Tensor: ...
    def __eq__(self, other: _TensorCompatible) -> Tensor: ...
    def __ne__(self, other: _TensorCompatible) -> Tensor: ...
    def __ge__(self, other: _TensorCompatible) -> Tensor: ...
    def __gt__(self, other: _TensorCompatible) -> Tensor: ...
    def __le__(self, other: _TensorCompatible) -> Tensor: ...
    def __lt__(self, other: _TensorCompatible) -> Tensor: ...
    def __bool__(self) -> NoReturn: ...
    def __getitem__(self, slice_spec: int | slice | tuple[int | slice, ...]) -> Tensor: ...
    def __len__(self) -> int: ...
    # This only works for rank 0 tensors.
    def __index__(self) -> int: ...
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class TensorShape:
    def __init__(self, dims: Iterable[int | None]): ...
    @property
    def rank(self) -> int: ...
    def as_list(self) -> list[int | None]: ...
    def assert_has_rank(self, rank: int) -> None: ...
    def __bool__(self) -> _bool: ...
    @overload
    def __getitem__(self, key: int) -> int | None: ...
    @overload
    def __getitem__(self, key: slice) -> TensorShape: ...
    def __iter__(self) -> Iterator[int | None]: ...
    def __len__(self) -> int: ...
    def __add__(self, other: Iterable[int | None]) -> TensorShape: ...
    def __radd__(self, other: Iterable[int | None]) -> TensorShape: ...
    def __eq__(self, other: Iterable[int | None]) -> _bool: ...  # type: ignore
    def __getattr__(self, name: str) -> Any: ...  # incomplete
